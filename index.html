<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Minecraft Journey Planner</title>

    <link rel="icon" href="https://cdn.discordapp.com/icons/1281634772694863883/1b8f50125d0f80d55cd015014ea2fdbc.png?size=160&amp;quality=lossless" type="image/png">
    <style>
        body { font-family: sans-serif; padding: 20px; background: #f0f0f0; }
        h1 { text-align: center; }
        #planner { max-width: 800px; margin: 0 auto; background: white; padding: 20px; border-radius: 10px; box-shadow: 0 0 15px rgba(0,0,0,0.1); }
        select, button { padding: 8px; margin: 5px; font-size: 16px; }
        #result { margin-top: 20px; background: #e0f7fa; padding: 15px; border-radius: 8px; }
        #map { margin-top: 30px; text-align: center; }
        img { max-width: 100%; border: 2px solid #ccc; border-radius: 10px; }
    </style>
</head>
<body>
    <h1>Minecraft Journey Planner</h1>
    <div id="planner">
        <label for="start">Van:</label>
        <select id="start"></select>

        <label for="end">Naar:</label>
        <select id="end"></select>

        <label for="preference">Voorkeur:</label>
        <select id="preference">
            <option value="minste_stations">Minste stations</option>
            <option value="minste_overstappen">Minste overstappen</option>
        </select>

        <button onclick="calculateRoute()">Plan Reis</button>

        <div id="result"></div>
        <div id="map">
            <h3>Metrokaart</h3>
            <img src="https://raw.githubusercontent.com/LowerTMM10/MinecraftJourneyPlanner/main/mycraft.png" alt="Metrokaart">
        </div>
    </div>

    <script>
        let graph = {};
        let stations = [];
        let lineDetails = {}; // Belangrijk: Maak lineDetails globaal toegankelijk

        console.log("--- Pagina geladen, start data fetching ---");

        // Correcte fetch URL naar de ruwe GitHub-link van journey_data.json
        fetch('https://raw.githubusercontent.com/LowerTMM10/MinecraftJourneyPlanner/main/journey_data.json')
            .then(res => {
                console.log("Fetch response status:", res.status, res.statusText);
                if (!res.ok) {
                    throw new Error(`HTTP error! status: ${res.status} - Controleer of de GitHub URL correct is en het bestand bestaat.`);
                }
                return res.json();
            })
            .then(data => {
                console.log("Loaded raw data:", data); // Check de ruwe geladen JSON data
                graph = {};
                lineDetails = data.lineDetails || {}; // Deze regel laadt lineDetails uit de JSON!
                console.log("Loaded lineDetails from JSON:", lineDetails); // Bevestig de inhoud van lineDetails

                // Zorg ervoor dat stations ook uniek zijn en consistent in hoofdletters/kleine letters
                // Door `new Set()` te gebruiken en dan te sorteren
                // Eerst alle stationnamen normaliseren naar één casing voor de Set, dan sorteren.
                // Dit helpt bij het omgaan met 'City Central' en 'City central' uit de JSON.
                const uniqueStationsSet = new Set();
                data.stations.forEach(s => uniqueStationsSet.add(s));
                stations = [...uniqueStationsSet].sort();
                console.log("Processed stations array:", stations);

                // Normaliseer connection namen (bijv. alles naar 'City Central' i.p.v. 'City central')
                data.connections.forEach(conn => {
                    // Zoek de 'correcte' casing uit de reeds genormaliseerde stationslijst
                    // Dit zorgt ervoor dat de sleutels in 'graph' consistent zijn.
                    const fromStation = stations.find(s => s.toLowerCase() === conn.from.toLowerCase()) || conn.from;
                    const toStation = stations.find(s => s.toLowerCase() === conn.to.toLowerCase()) || conn.to;

                    if (!graph[fromStation]) graph[fromStation] = [];
                    graph[fromStation].push({ to: toStation, line: conn.line }); // Let op: line naam hier is zoals in JSON
                });
                console.log("Constructed graph:", graph); // Controleer de opbouw van de graaf

                populateDropdowns();
                console.log("Dropdowns populated.");
            })
            .catch(error => {
                console.error("Fout bij het laden van de journey data:", error);
                document.getElementById("result").innerHTML = `<p>Er is een probleem opgetreden bij het laden van de stationsdata: ${error.message}</p>`;
                console.log("Error message displayed in result div.");
            });

        function populateDropdowns() {
            const startSel = document.getElementById("start");
            const endSel = document.getElementById("end");
            // stations zijn nu al uniek en gesorteerd vanuit de fetch-stap
            stations.forEach(station => {
                let opt1 = new Option(station, station);
                let opt2 = new Option(station, station);
                startSel.add(opt1);
                startSel.add(opt2); // Voeg toe aan start
                endSel.add(opt2.cloneNode(true)); // Kloon voor einde, om dubbele ID's te voorkomen indien nodig
            });
            console.log("Dropdowns options added.");
        }

        function calculateRoute() {
            console.log("--- calculateRoute() gestart ---");
            const start = document.getElementById("start").value;
            const end = document.getElementById("end").value;
            const preference = document.getElementById("preference").value;

            console.log("Geselecteerde stations:", start, end, "Voorkeur:", preference);

            // Normaliseer de geselecteerde stations (indien nodig, afhankelijk van de JSON opschoning)
            // Dit zorgt ervoor dat "City central" (gekozen door gebruiker) matcht met "City Central" (in graph)
            const normalizedStart = stations.find(s => s.toLowerCase() === start.toLowerCase()) || start;
            const normalizedEnd = stations.find(s => s.toLowerCase() === end.toLowerCase()) || end;

            console.log("Genormaliseerde stations voor zoekopdracht:", normalizedStart, normalizedEnd);
            console.log("Graaf entry voor startstation:", graph[normalizedStart]);
            console.log("Graaf entry voor eindstation:", graph[normalizedEnd]);

            if (!graph[normalizedStart] || !graph[normalizedEnd]) {
                document.getElementById("result").innerHTML = "<p>Ongeldig start- of eindstation. Controleer je selectie.</p>";
                console.log("Melding: Ongeldig start- of eindstation weergegeven.");
                return;
            }

            let resultPath = [];
            let found = false;

            if (preference === "minste_stations") {
                console.log("BFS (Minste stations) algoritme geselecteerd.");
                let queue = [{ station: normalizedStart, path: [], visited: new Set([normalizedStart]) }];

                while (queue.length > 0 && !found) {
                    let current = queue.shift();
                    let { station, path, visited } = current;
                    // console.log("BFS: Huidig station:", station, "Pad lengte:", path.length); // Kan veel output geven

                    if (station === normalizedEnd) {
                        resultPath = path;
                        found = true;
                        console.log("BFS: Pad gevonden naar eindstation!");
                        break;
                    }

                    let neighbors = graph[station] || [];
                    neighbors.forEach(next => {
                        if (!visited.has(next.to)) {
                            queue.push({
                                station: next.to,
                                path: [...path, { from: station, to: next.to, line: next.line }],
                                visited: new Set(visited).add(next.to)
                            });
                        }
                    });
                }

            } else if (preference === "minste_overstappen") {
                console.log("Dijkstra-achtig (Minste overstappen) algoritme geselecteerd.");
                let queue = [{ station: normalizedStart, path: [], visited: new Set([normalizedStart]), transfers: 0, lastLine: null }];

                let bestPathsToStation = new Map();
                bestPathsToStation.set(normalizedStart, { transfers: 0, pathLength: 0 });

                while (queue.length > 0 && !found) {
                    queue.sort((a, b) => {
                        if (a.transfers !== b.transfers) {
                            return a.transfers - b.transfers;
                        }
                        return a.path.length - b.path.length;
                    });

                    let current = queue.shift();
                    let { station, path, visited, transfers, lastLine } = current;
                    // console.log("Dijkstra: Huidig station:", station, "Overstappen:", transfers, "Pad lengte:", path.length); // Kan veel output geven

                    const currentBest = bestPathsToStation.get(station);
                    if (currentBest && (transfers > currentBest.transfers || (transfers === currentBest.transfers && path.length > currentBest.pathLength))) {
                        // console.log("Dijkstra: Overslaan, al een betere route naar", station);
                        continue;
                    }
                                        
                    if (station === normalizedEnd) {
                        resultPath = path;
                        found = true;
                        console.log("Dijkstra: Pad gevonden naar eindstation!");
                        break;
                    }

                    let neighbors = graph[station] || [];
                    neighbors.forEach(next => {
                        let newTransfers = transfers;
                        if (lastLine !== null && next.line !== lastLine) {
                            newTransfers++;
                        }

                        let newPath = [...path, { from: station, to: next.to, line: next.line }];

                        const existingBestToNext = bestPathsToStation.get(next.to);
                        if (!existingBestToNext || (newTransfers < existingBestToNext.transfers) || (newTransfers === existingBestToNext.transfers && newPath.length < existingBestToNext.pathLength)) {
                            queue.push({
                                station: next.to,
                                path: newPath,
                                visited: new Set(visited).add(next.to),
                                transfers: newTransfers,
                                lastLine: next.line
                            });
                            bestPathsToStation.set(next.to, { transfers: newTransfers, pathLength: newPath.length });
                        }
                    });
                }
            }

            const resultDiv = document.getElementById("result");
            console.log("Algoritme voltooid. Pad gevonden (found):", found, "Resultaatpad:", resultPath);
            if (found) {
                let lines = resultPath.map(step => {
                    // lineDetails wordt geladen vanuit de JSON, dus check of de line naam matcht
                    const emoji = lineDetails[step.line] ? lineDetails[step.line].colorEmoji : '';
                    console.log(`Stap: ${step.from} → ${step.to} via ${step.line}, Emoji opgezocht: ${emoji}`); // Log elke stap's emoji lookup
                    return `➡️ ${emoji} <b>${step.from}</b> → <b>${step.to}</b> via <i>${step.line}</i>`;
                }).join("<br>");
                resultDiv.innerHTML = `<h3>Route:</h3>${lines}`;
                console.log("Route weergegeven in resultaat div.");
            } else {
                resultDiv.innerHTML = "<p>Geen route gevonden.</p>";
                console.log("Melding: Geen route gevonden weergegeven in resultaat div.");
            }
            console.log("--- calculateRoute() einde ---");
        }
    </script>
</body>
</html>
